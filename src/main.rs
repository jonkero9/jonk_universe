//  ⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠛⠛⠛⠋⠉⠈⠉⠉⠉⠉⠛⠻⢿⣿⣿⣿⣿⣿⣿⣿
//  ⣿⣿⣿⣿⣿⡿⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⢿⣿⣿⣿⣿
//  ⣿⣿⣿⣿⡏⣀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣤⣤⣄⡀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿
//  ⣿⣿⣿⢏⣴⣿⣷⠀⠀⠀⠀⠀⢾⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠈⣿⣿
//  ⣿⣿⣟⣾⣿⡟⠁⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣷⢢⠀⠀⠀⠀⠀⠀⠀⢸⣿
//  ⣿⣿⣿⣿⣟⠀⡴⠄⠀⠀⠀⠀⠀⠀⠙⠻⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⣿
//  ⣿⣿⣿⠟⠻⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠶⢴⣿⣿⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⣿
//  ⣿⣁⡀⠀⠀⢰⢠⣦⠀⠀⠀⠀⠀⠀⠀⠀⢀⣼⣿⣿⣿⣿⣿⡄⠀⣴⣶⣿⡄⣿
//  ⣿⡋⠀⠀⠀⠎⢸⣿⡆⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⣿⠗⢘⣿⣟⠛⠿⣼
//  ⣿⣿⠋⢀⡌⢰⣿⡿⢿⡀⠀⠀⠀⠀⠀⠙⠿⣿⣿⣿⣿⣿⡇⠀⢸⣿⣿⣧⢀⣼
//  ⣿⣿⣷⢻⠄⠘⠛⠋⠛⠃⠀⠀⠀⠀⠀⢿⣧⠈⠉⠙⠛⠋⠀⠀⠀⣿⣿⣿⣿⣿
//  ⣿⣿⣧⠀⠈⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠟⠀⠀⠀⠀⢀⢃⠀⠀⢸⣿⣿⣿⣿
//  ⣿⣿⡿⠀⠴⢗⣠⣤⣴⡶⠶⠖⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡸⠀⣿⣿⣿⣿
//  ⣿⣿⣿⡀⢠⣾⣿⠏⠀⠠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠉⠀⣿⣿⣿⣿
//  ⣿⣿⣿⣧⠈⢹⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿
//  ⣿⣿⣿⣿⡄⠈⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣴⣾⣿⣿⣿⣿⣿
//  ⣿⣿⣿⣿⣧⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿
//  ⣿⣿⣿⣿⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
//  ⣿⣿⣿⣿⣿⣦⣄⣀⣀⣀⣀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
//  ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡄⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
//  ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀⠀⠙⣿⣿⡟⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿
//  ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⠀⠁⠀⠀⠹⣿⠃⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿
//  ⣿⣿⣿⣿⣿⣿⣿⣿⡿⠛⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⢐⣿⣿⣿⣿⣿⣿⣿⣿⣿
//  ⣿⣿⣿⣿⠿⠛⠉⠉⠁⠀⢻⣿⡇⠀⠀⠀⠀⠀⠀⢀⠈⣿⣿⡿⠉⠛⠛⠛⠉⠉
//  ⣿⡿⠋⠁⠀⠀⢀⣀⣠⡴⣸⣿⣇⡄⠀⠀⠀⠀⢀⡿⠄⠙⠛⠀⣀⣠⣤⣤⠄⠀
use game_color::COLORS;
use model::star_system::StarSystem;
use model::vectors::Vector2DI;
use raylib::consts::MouseButton::*;
use raylib::prelude::*;
use std::collections::HashMap;
use std::time::Instant;
use u_gen::factory;
use ui::uni_map_window::UniMapWindow;
use ui::uni_map_controller;

pub mod game_color;
pub mod model;
pub mod u_gen;
pub mod ui;

#[derive(Debug, Clone)]
enum ScreenState {
    UniMap,
    StarSystemMap,
}

fn main() {
    // Set up initial Objects
    let mut uni_map_window: UniMapWindow = UniMapWindow::new(16.);
    let mut selected_star: Option<StarSystem> = None;
    let mut screen_state = ScreenState::UniMap;

    // initialize raylib object
    let (mut rl, thread) = raylib::init()
        .vsync()
        .resizable()
        .size(960, 640)
        .title("Jspace")
        .build();
    rl.set_target_fps(75);

    // main game loop
    while !rl.window_should_close() {
        let timer = Instant::now();

        let star_map: HashMap<u64, StarSystem> = factory::new_universe(
            Vector2DI {
                x: uni_map_window.global_pos.x as i32,
                y: uni_map_window.global_pos.y as i32,
            },
            uni_map_window.n_sectors,
        );

        uni_map_window.n_sectors = Vector2DI {
            x: rl.get_screen_width() / uni_map_window.sec_size as i32,
            y: rl.get_screen_height() / uni_map_window.sec_size as i32,
        };

        // Handle User Input
        match screen_state {
            ScreenState::UniMap => {
                uni_map_controller::handle_uni_map_input(&rl, &mut uni_map_window);
                if let Some(star) =
                    uni_map_controller::handle_select_star_unimap(&rl, &star_map, &uni_map_window)
                {
                    selected_star = Some(star.clone());
                };
            }
            ScreenState::StarSystemMap => {}
        }
        screen_state = handle_screen_state_click(&rl, &screen_state);

        // Begin Draw
        let mut draw = rl.begin_drawing(&thread);
        draw.clear_background(Color::BLACK);

        match screen_state {
            ScreenState::UniMap => {
                UniMapWindow::draw(&star_map, timer, &mut draw, &uni_map_window);
            }
            ScreenState::StarSystemMap => if let Some(_pat) = &selected_star {
                //todo
            },
        }
    }
}

fn handle_screen_state_click(rl: &RaylibHandle, screen_state: &ScreenState) -> ScreenState {
    match screen_state {
        ScreenState::UniMap => {
            if rl.is_mouse_button_pressed(MOUSE_LEFT_BUTTON) {
                return swap_screen_state(screen_state);
            }
            screen_state.clone()
        }
        ScreenState::StarSystemMap => {
            if rl.is_mouse_button_pressed(MOUSE_RIGHT_BUTTON) {
                return swap_screen_state(screen_state);
            }
            screen_state.clone()
        }
    }
}

fn swap_screen_state(screen_state: &ScreenState) -> ScreenState {
    match screen_state {
        ScreenState::UniMap => ScreenState::StarSystemMap,
        ScreenState::StarSystemMap => ScreenState::UniMap,
    }
}


