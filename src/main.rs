//  ⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠛⠛⠛⠋⠉⠈⠉⠉⠉⠉⠛⠻⢿⣿⣿⣿⣿⣿⣿⣿
//  ⣿⣿⣿⣿⣿⡿⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⢿⣿⣿⣿⣿
//  ⣿⣿⣿⣿⡏⣀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣤⣤⣄⡀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿
//  ⣿⣿⣿⢏⣴⣿⣷⠀⠀⠀⠀⠀⢾⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠈⣿⣿
//  ⣿⣿⣟⣾⣿⡟⠁⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣷⢢⠀⠀⠀⠀⠀⠀⠀⢸⣿
//  ⣿⣿⣿⣿⣟⠀⡴⠄⠀⠀⠀⠀⠀⠀⠙⠻⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⣿
//  ⣿⣿⣿⠟⠻⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠶⢴⣿⣿⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⣿
//  ⣿⣁⡀⠀⠀⢰⢠⣦⠀⠀⠀⠀⠀⠀⠀⠀⢀⣼⣿⣿⣿⣿⣿⡄⠀⣴⣶⣿⡄⣿
//  ⣿⡋⠀⠀⠀⠎⢸⣿⡆⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⣿⠗⢘⣿⣟⠛⠿⣼
//  ⣿⣿⠋⢀⡌⢰⣿⡿⢿⡀⠀⠀⠀⠀⠀⠙⠿⣿⣿⣿⣿⣿⡇⠀⢸⣿⣿⣧⢀⣼
//  ⣿⣿⣷⢻⠄⠘⠛⠋⠛⠃⠀⠀⠀⠀⠀⢿⣧⠈⠉⠙⠛⠋⠀⠀⠀⣿⣿⣿⣿⣿
//  ⣿⣿⣧⠀⠈⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠟⠀⠀⠀⠀⢀⢃⠀⠀⢸⣿⣿⣿⣿
//  ⣿⣿⡿⠀⠴⢗⣠⣤⣴⡶⠶⠖⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡸⠀⣿⣿⣿⣿
//  ⣿⣿⣿⡀⢠⣾⣿⠏⠀⠠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠉⠀⣿⣿⣿⣿
//  ⣿⣿⣿⣧⠈⢹⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿
//  ⣿⣿⣿⣿⡄⠈⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣴⣾⣿⣿⣿⣿⣿
//  ⣿⣿⣿⣿⣧⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿
//  ⣿⣿⣿⣿⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
//  ⣿⣿⣿⣿⣿⣦⣄⣀⣀⣀⣀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
//  ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡄⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
//  ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀⠀⠙⣿⣿⡟⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿
//  ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⠀⠁⠀⠀⠹⣿⠃⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿
//  ⣿⣿⣿⣿⣿⣿⣿⣿⡿⠛⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⢐⣿⣿⣿⣿⣿⣿⣿⣿⣿
//  ⣿⣿⣿⣿⠿⠛⠉⠉⠁⠀⢻⣿⡇⠀⠀⠀⠀⠀⠀⢀⠈⣿⣿⡿⠉⠛⠛⠛⠉⠉
//  ⣿⡿⠋⠁⠀⠀⢀⣀⣠⡴⣸⣿⣇⡄⠀⠀⠀⠀⢀⡿⠄⠙⠛⠀⣀⣠⣤⣤⠄⠀
//  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣤⣤⣶⣤⣤⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣄⠀⠀⠀⠀⠀⠀
//  ⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⡿⠋⠉⠛⠛⠛⠿⣿⠿⠿⢿⣇⠀⠀⠀⠀⠀
//  ⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⣿⣿⠟⠀⠀⠀⠀⠀⡀⢀⣽⣷⣆⡀⠙⣧⠀⠀⠀⠀
//  ⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⣿⣷⠶⠋⠀⠀⣠⣤⣤⣉⣉⣿⠙⣿⠀⢸⡆⠀⠀⠀
//  ⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⠁⠀⠀⠴⡟⣻⣿⣿⣿⣿⣿⣶⣿⣦⡀⣇⠀⠀⠀
//  ⠀⠀⠀⠀⠀⠀⢨⠟⡿⠻⣿⠃⠀⠀⠀⠻⢿⣿⣿⣿⣿⣿⠏⢹⣿⣿⣿⢿⡇⠀⠀
//  ⠀⠀⠀⠀⠀⠀⣿⣼⣷⡶⣿⣄⠀⠀⠀⠀⠀⢉⣿⣿⣿⡿⠀⠸⣿⣿⡿⣷⠃⠀⠀
//  ⠀⠀⠀⠀⠀⠀⢻⡿⣦⢀⣿⣿⣄⡀⣀⣰⠾⠛⣻⣿⣿⣟⣲⡀⢸⡿⡟⠹⡆⠀⠀
//  ⠀⠀⠀⠀⠀⠀⠀⢰⠞⣾⣿⡛⣿⣿⣿⣿⣰⣾⣿⣿⣿⣿⣿⣿⣿⣿⡇⢰⡇⠀⠀
//  ⠀⠀⠀⠀⠀⠀⠀⠘⠀⣿⡽⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢿⠿⣍⣿⣧⡏⠀⠀⠀
//  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣷⣿⣿⣿⣿⣿⣿⣿⣿⣷⣮⣽⣿⣷⣙⣿⡟⠀⠀⠀⠀
//  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⣹⡿⠇⠀⠀⠀⠀
//  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡧⣦⠀⠀⠀⠀
//  ⠀⠀⠀⠀⠀⢠⡆⠀⠀⠀⠀⠀⠀⠀⠉⠻⣿⣿⣾⣿⣿⣿⣿⣿⣿⡶⠏⠀⠀⠀⠀
//  ⣀⣠⣤⡴⠞⠛⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠚⣿⣿⣿⠿⣿⣿⠿⠟⠁⠀⠀⠀⠀⠀
//  ⠉⠀⢀⡴⠂⠀⠀⠀⠀⠀⠀⠀⠀⢠⠀⠀⢀⣿⣿⠁⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀
//  ⣠⣴⡿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⠀⠀⣾⣿⠋⠀⢠⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀
//  ⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣆⣼⣿⠁⢠⠃⠈⠓⠦⣄⡀⠀⠀⠀⠀⠀⠀
//  ⠻⠿⢷⣦⣤⣤⣤⣦⣄⣀⣀⠀⢀⣿⣿⠻⣿⣰⠻⠀⠸⣧⡀⠀⠉⠳⣄⠀⠀⠀⠀
//  ⠀⠀⠀⠀⠀⠈⠉⠉⠙⠛⠿⣦⣼⡏⢻⣿⣿⠇⠀⠁⠀⠻⣿⠙⣶⣄⠈⠳⣄⡀⠀
//  ⠀⠀⠀⠀⠀⠀⠀⠁⣐⠀⠀⠀⠈⠳⡘⣿⡟⣀⡠⠿⠶⠒⠟⠓⠀⠹⡄⢴⣬⣍⡁
//  ⠀⠀⠀⠀⠀⠀⠀⠀⠙⢀⣀⠐⠲⠤⠁⢘⣠⣿⣷⣦⠀⠀⠀⠀⠀⠀⠙⢿⣿⣏⠁
//  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠀⠀⠀⠀⠈⣿⣿⣷⣯⠀⠀⠀⠀⠀⠀⠀⠀⠉⠻⠆
//  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⢦⠀⢹⣿⣏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⣸⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//  ⠀⠀⠀⠐⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//  ⠀⡟⢬⣿⣷⣤⣀⣄⣀⡀⠀⠀⠀⠀⠀⠀⠈⣿⣿⡄⣉⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀

use game_color::COLORS;
use model::star_system::StarSystem;
use model::vectors::Vector2DI;
use raylib::consts::MouseButton::*;
use raylib::prelude::*;
use std::collections::HashMap;
use std::time::Instant;
use u_gen::factory;
use ui::uni_map_controller;
use ui::uni_map_window::UniMapWindow;

pub mod game_color;
pub mod model;
pub mod u_gen;
pub mod ui;

#[derive(Debug, Clone)]
enum ScreenState {
    UniMap,
    StarSystemMap,
}

fn main() {
    // Set up initial Objects
    let mut uni_map_window: UniMapWindow = UniMapWindow::new(16.);
    let mut selected_star: Option<StarSystem> = None;
    let mut screen_state = ScreenState::UniMap;

    // initialize raylib object
    let (mut rl, thread) = raylib::init()
        .vsync()
        .resizable()
        .size(960, 640)
        .title("Jspace")
        .build();
    rl.set_target_fps(75);

    // main game loop
    while !rl.window_should_close() {
        let timer = Instant::now();

        let star_map: HashMap<u64, StarSystem> = factory::new_universe(
            Vector2DI {
                x: uni_map_window.global_pos.x as i32,
                y: uni_map_window.global_pos.y as i32,
            },
            uni_map_window.n_sectors,
        );

        // Handle User Input
        match screen_state {
            ScreenState::UniMap => {
                uni_map_window.n_sectors = Vector2DI {
                    x: rl.get_screen_width() / uni_map_window.sec_size as i32,
                    y: rl.get_screen_height() / uni_map_window.sec_size as i32,
                };
                uni_map_controller::handle_uni_map_input(&rl, &mut uni_map_window);
                if let Some(star) =
                    uni_map_controller::handle_select_star_unimap(&rl, &star_map, &uni_map_window)
                {
                    selected_star = Some(star.clone());
                };
            }
            ScreenState::StarSystemMap => {}
        }
        screen_state = handle_screen_state_click(&rl, &screen_state);

        // Begin Draw
        let mut draw = rl.begin_drawing(&thread);
        draw.clear_background(Color::BLACK);

        match screen_state {
            ScreenState::UniMap => {
                handle_uni_map_draw(&star_map, &mut draw, &uni_map_window);
                draw_uni_debug_widget(timer, &uni_map_window, &mut draw)
            }
            ScreenState::StarSystemMap => {
                if let Some(pat) = &selected_star {
                    draw_debug_star_menu(pat, &mut draw);
                }
            }
        }
    }
}

fn handle_uni_map_draw(
    star_map: &HashMap<u64, StarSystem>,
    draw: &mut RaylibDrawHandle,
    uni_map_window: &UniMapWindow,
) {
    for y in 0..uni_map_window.n_sectors.y {
        for x in 0..uni_map_window.n_sectors.x {
            let global_sec = Vector2DI {
                x: uni_map_window.global_pos.x as i32 + x,
                y: uni_map_window.global_pos.y as i32 + y,
            };
            let hash_key = jonk_utils::cantor_hash(global_sec.x, global_sec.y);
            if let Some(star) = star_map.get(&hash_key) {
                let sec_to_screen = Vector2DI {
                    x: x * uni_map_window.sec_size as i32,
                    y: y * uni_map_window.sec_size as i32,
                };
                draw.draw_circle(
                    sec_to_screen.x + (uni_map_window.sec_size / 2.) as i32,
                    sec_to_screen.y + (uni_map_window.sec_size / 2.) as i32,
                    (star.radius / 2000.) * (uni_map_window.sec_size / 2.),
                    Color::from(star.star_color),
                );
            }
        }
    }
    handle_mouse_hover(star_map, draw, uni_map_window);
}

fn handle_mouse_hover(
    star_map: &HashMap<u64, StarSystem>,
    draw: &mut RaylibDrawHandle,
    uni_map_window: &UniMapWindow,
) {
    if let Some(star) = star_map.get(&jonk_utils::cantor_hash(
        uni_map_window.global_pos.x as i32 + (draw.get_mouse_x() / uni_map_window.sec_size as i32),
        uni_map_window.global_pos.y as i32 + (draw.get_mouse_y() / uni_map_window.sec_size as i32),
    )) {
        draw_debug_star_menu(star, draw);
    }
}

fn draw_debug_star_menu(star: &StarSystem, draw: &mut RaylibDrawHandle) {
    let lines = vec![
        format!("Radius: {:.2}", star.radius),
        format!("Luminosity: {:.2} lums", star.luminosity),
        format!("Temp: {:.2}K", star.surface_temp),
        format!("Mass: {:.2} Solar masses", star.mass),
        format!("Planets: {}", star.planets.len()),
        format!("Color: {:?}", star.star_color),
        format!("location: {}, {}", star.location.x, star.location.y),
    ];
    let planet_lines: Vec<String> = star
        .planets
        .iter()
        .map(|p| format!(" planet : {}", p.mass))
        .collect();
    let collect: Vec<&String> = lines.iter().chain(planet_lines.iter()).collect();
    draw_lines(draw, collect, 32, 12, 160);
}

fn draw_lines(draw: &mut RaylibDrawHandle, lines: Vec<&String>, f_size: i32, s_x: i32, s_y: i32) {
    let mut start_y = s_y;
    draw.draw_rectangle(s_x, start_y, 540, f_size * lines.len() as i32, COLORS.bg);
    for s in lines {
        draw.draw_text(s, s_x, start_y, f_size, Color::WHITE);
        start_y += f_size;
    }
}

fn handle_screen_state_click(rl: &RaylibHandle, screen_state: &ScreenState) -> ScreenState {
    match screen_state {
        ScreenState::UniMap => {
            if rl.is_mouse_button_pressed(MOUSE_LEFT_BUTTON) {
                return swap_screen_state(screen_state);
            }
            screen_state.clone()
        }
        ScreenState::StarSystemMap => {
            if rl.is_mouse_button_pressed(MOUSE_RIGHT_BUTTON) {
                return swap_screen_state(screen_state);
            }
            screen_state.clone()
        }
    }
}

fn swap_screen_state(screen_state: &ScreenState) -> ScreenState {
    match screen_state {
        ScreenState::UniMap => ScreenState::StarSystemMap,
        ScreenState::StarSystemMap => ScreenState::UniMap,
    }
}

fn draw_uni_debug_widget(timer: Instant, uni_map_win: &UniMapWindow, draw: &mut RaylibDrawHandle) {
    let elasped = timer.elapsed().as_secs_f64();
    if uni_map_win.uni_map_debug_info {
        draw_lines(
            draw,
            vec![
                &format!(
                    "nsecs: {}, {}",
                    uni_map_win.n_sectors.x, uni_map_win.n_sectors.y
                ),
                &format!("run time seconds: {:.6}", elasped),
                &format!("Zoom: {:.2} ", uni_map_win.sec_size),
                &format!(
                    "Sector: {}, {}",
                    uni_map_win.global_pos.x, uni_map_win.global_pos.y
                ),
            ],
            32,
            12,
            12,
        );
    }
}
