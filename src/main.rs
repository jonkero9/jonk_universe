//  ⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠛⠛⠛⠋⠉⠈⠉⠉⠉⠉⠛⠻⢿⣿⣿⣿⣿⣿⣿⣿
//  ⣿⣿⣿⣿⣿⡿⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⢿⣿⣿⣿⣿
//  ⣿⣿⣿⣿⡏⣀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣤⣤⣄⡀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿
//  ⣿⣿⣿⢏⣴⣿⣷⠀⠀⠀⠀⠀⢾⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠈⣿⣿
//  ⣿⣿⣟⣾⣿⡟⠁⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣷⢢⠀⠀⠀⠀⠀⠀⠀⢸⣿
//  ⣿⣿⣿⣿⣟⠀⡴⠄⠀⠀⠀⠀⠀⠀⠙⠻⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⣿
//  ⣿⣿⣿⠟⠻⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠶⢴⣿⣿⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⣿
//  ⣿⣁⡀⠀⠀⢰⢠⣦⠀⠀⠀⠀⠀⠀⠀⠀⢀⣼⣿⣿⣿⣿⣿⡄⠀⣴⣶⣿⡄⣿
//  ⣿⡋⠀⠀⠀⠎⢸⣿⡆⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⣿⠗⢘⣿⣟⠛⠿⣼
//  ⣿⣿⠋⢀⡌⢰⣿⡿⢿⡀⠀⠀⠀⠀⠀⠙⠿⣿⣿⣿⣿⣿⡇⠀⢸⣿⣿⣧⢀⣼
//  ⣿⣿⣷⢻⠄⠘⠛⠋⠛⠃⠀⠀⠀⠀⠀⢿⣧⠈⠉⠙⠛⠋⠀⠀⠀⣿⣿⣿⣿⣿
//  ⣿⣿⣧⠀⠈⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠟⠀⠀⠀⠀⢀⢃⠀⠀⢸⣿⣿⣿⣿
//  ⣿⣿⡿⠀⠴⢗⣠⣤⣴⡶⠶⠖⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡸⠀⣿⣿⣿⣿
//  ⣿⣿⣿⡀⢠⣾⣿⠏⠀⠠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠉⠀⣿⣿⣿⣿
//  ⣿⣿⣿⣧⠈⢹⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿
//  ⣿⣿⣿⣿⡄⠈⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣴⣾⣿⣿⣿⣿⣿
//  ⣿⣿⣿⣿⣧⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿
//  ⣿⣿⣿⣿⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
//  ⣿⣿⣿⣿⣿⣦⣄⣀⣀⣀⣀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
//  ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡄⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
//  ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀⠀⠙⣿⣿⡟⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿
//  ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⠀⠁⠀⠀⠹⣿⠃⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿
//  ⣿⣿⣿⣿⣿⣿⣿⣿⡿⠛⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⢐⣿⣿⣿⣿⣿⣿⣿⣿⣿
//  ⣿⣿⣿⣿⠿⠛⠉⠉⠁⠀⢻⣿⡇⠀⠀⠀⠀⠀⠀⢀⠈⣿⣿⡿⠉⠛⠛⠛⠉⠉
//  ⣿⡿⠋⠁⠀⠀⢀⣀⣠⡴⣸⣿⣇⡄⠀⠀⠀⠀⢀⡿⠄⠙⠛⠀⣀⣠⣤⣤⠄⠀
//  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣤⣤⣶⣤⣤⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣄⠀⠀⠀⠀⠀⠀
//  ⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⡿⠋⠉⠛⠛⠛⠿⣿⠿⠿⢿⣇⠀⠀⠀⠀⠀
//  ⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⣿⣿⠟⠀⠀⠀⠀⠀⡀⢀⣽⣷⣆⡀⠙⣧⠀⠀⠀⠀
//  ⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⣿⣷⠶⠋⠀⠀⣠⣤⣤⣉⣉⣿⠙⣿⠀⢸⡆⠀⠀⠀
//  ⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⠁⠀⠀⠴⡟⣻⣿⣿⣿⣿⣿⣶⣿⣦⡀⣇⠀⠀⠀
//  ⠀⠀⠀⠀⠀⠀⢨⠟⡿⠻⣿⠃⠀⠀⠀⠻⢿⣿⣿⣿⣿⣿⠏⢹⣿⣿⣿⢿⡇⠀⠀
//  ⠀⠀⠀⠀⠀⠀⣿⣼⣷⡶⣿⣄⠀⠀⠀⠀⠀⢉⣿⣿⣿⡿⠀⠸⣿⣿⡿⣷⠃⠀⠀
//  ⠀⠀⠀⠀⠀⠀⢻⡿⣦⢀⣿⣿⣄⡀⣀⣰⠾⠛⣻⣿⣿⣟⣲⡀⢸⡿⡟⠹⡆⠀⠀
//  ⠀⠀⠀⠀⠀⠀⠀⢰⠞⣾⣿⡛⣿⣿⣿⣿⣰⣾⣿⣿⣿⣿⣿⣿⣿⣿⡇⢰⡇⠀⠀
//  ⠀⠀⠀⠀⠀⠀⠀⠘⠀⣿⡽⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢿⠿⣍⣿⣧⡏⠀⠀⠀
//  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣷⣿⣿⣿⣿⣿⣿⣿⣿⣷⣮⣽⣿⣷⣙⣿⡟⠀⠀⠀⠀
//  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⣹⡿⠇⠀⠀⠀⠀
//  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡧⣦⠀⠀⠀⠀
//  ⠀⠀⠀⠀⠀⢠⡆⠀⠀⠀⠀⠀⠀⠀⠉⠻⣿⣿⣾⣿⣿⣿⣿⣿⣿⡶⠏⠀⠀⠀⠀
//  ⣀⣠⣤⡴⠞⠛⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠚⣿⣿⣿⠿⣿⣿⠿⠟⠁⠀⠀⠀⠀⠀
//  ⠉⠀⢀⡴⠂⠀⠀⠀⠀⠀⠀⠀⠀⢠⠀⠀⢀⣿⣿⠁⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀
//  ⣠⣴⡿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⠀⠀⣾⣿⠋⠀⢠⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀
//  ⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣆⣼⣿⠁⢠⠃⠈⠓⠦⣄⡀⠀⠀⠀⠀⠀⠀
//  ⠻⠿⢷⣦⣤⣤⣤⣦⣄⣀⣀⠀⢀⣿⣿⠻⣿⣰⠻⠀⠸⣧⡀⠀⠉⠳⣄⠀⠀⠀⠀
//  ⠀⠀⠀⠀⠀⠈⠉⠉⠙⠛⠿⣦⣼⡏⢻⣿⣿⠇⠀⠁⠀⠻⣿⠙⣶⣄⠈⠳⣄⡀⠀
//  ⠀⠀⠀⠀⠀⠀⠀⠁⣐⠀⠀⠀⠈⠳⡘⣿⡟⣀⡠⠿⠶⠒⠟⠓⠀⠹⡄⢴⣬⣍⡁
//  ⠀⠀⠀⠀⠀⠀⠀⠀⠙⢀⣀⠐⠲⠤⠁⢘⣠⣿⣷⣦⠀⠀⠀⠀⠀⠀⠙⢿⣿⣏⠁
//  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠀⠀⠀⠀⠈⣿⣿⣷⣯⠀⠀⠀⠀⠀⠀⠀⠀⠉⠻⠆
//  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⢦⠀⢹⣿⣏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⣸⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//  ⠀⠀⠀⠐⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
//  ⠀⡟⢬⣿⣷⣤⣀⣄⣀⡀⠀⠀⠀⠀⠀⠀⠈⣿⣿⡄⣉⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀

use game_color::COLORS;
use model::star_system::StarSystem;
use raylib::consts::KeyboardKey::*;
use raylib::consts::MouseButton::*;
use raylib::prelude::*;
use std::collections::HashMap;
use std::time::Instant;
use u_gen::factory;

pub mod game_color;
pub mod model;
pub mod u_gen;

#[derive(Debug, Clone)]
enum ScreenState {
    UniMap,
    StarSystemMap,
}

#[derive(Debug, Clone, Copy)]
pub struct VecI {
    pub x: i32,
    pub y: i32,
}

fn main() {
    let mut sec_size: f32 = 16.;
    let mut global_pos = Vector2 { x: 0., y: 0. };

    let mut selected_star: Option<StarSystem> = None;

    let mut screen_state = ScreenState::UniMap;

    let (mut rl, thread) = raylib::init()
        .vsync()
        .resizable()
        .size(960, 640)
        .title("Jspace")
        .build();
    rl.set_target_fps(75);

    while !rl.window_should_close() {
        let timer = Instant::now();
        sec_size = handle_zoom(&rl, sec_size);

        handle_key_press(
            &rl,
            &mut global_pos,
            (128. * rl.get_frame_time()) / (sec_size / 16.),
        );

        let n_sectors = VecI {
            x: rl.get_screen_width() / sec_size as i32,
            y: rl.get_screen_height() / sec_size as i32,
        };

        let star_map: HashMap<u64, StarSystem> = factory::new_universe(
            VecI {
                x: global_pos.x as i32,
                y: global_pos.y as i32,
            },
            n_sectors,
        );
        if let Some(star) = handle_select_star(&rl, &star_map, &global_pos, sec_size as i32) {
            selected_star = Some(star.clone());
        };
        screen_state = handle_mouse_click(&rl, &screen_state);

        // Begin Draw
        let mut draw = rl.begin_drawing(&thread);
        draw.clear_background(Color::BLACK);

        match screen_state {
            ScreenState::UniMap => {
                handle_uni_map_draw(n_sectors, &mut global_pos, &star_map, sec_size, &mut draw)
            }
            ScreenState::StarSystemMap => {
                if let Some(pat) = &selected_star {
                    draw_debug_star_menu(&pat, &mut draw);
                }
            }
        }

        let elasped = timer.elapsed().as_secs_f64();
        draw_lines(
            &mut draw,
            vec![
                &format!("nsecs: {}, {}", n_sectors.x, n_sectors.y),
                &format!("run time seconds: {:.6}", elasped),
                &format!("Zoom: {:.2} ", sec_size),
                &format!("Sector: {}, {}", global_pos.x, global_pos.y),
            ],
            32,
            12,
            12,
        );
    }
}

fn handle_select_star<'a>(
    rl: &RaylibHandle,
    star_map: &'a HashMap<u64, StarSystem>,
    global_pos: &Vector2,
    sec_size: i32,
) -> Option<&'a StarSystem> {
    if rl.is_mouse_button_pressed(MOUSE_LEFT_BUTTON) {
        let mouse_x = rl.get_mouse_x() / sec_size;
        let mouse_y = rl.get_mouse_y() / sec_size;
        let hash =
            jonk_utils::cantor_hash(global_pos.x as i32 + mouse_x, global_pos.y as i32 + mouse_y);
        return star_map.get(&hash);
    }
    None
}

fn handle_uni_map_draw(
    n_sectors: VecI,
    global_pos: &mut Vector2,
    star_map: &HashMap<u64, StarSystem>,
    sec_size: f32,
    draw: &mut RaylibDrawHandle,
) {
    for y in 0..n_sectors.y {
        for x in 0..n_sectors.x {
            let global_sec = VecI {
                x: global_pos.x as i32 + x,
                y: global_pos.y as i32 + y,
            };
            let hash_key = jonk_utils::cantor_hash(global_sec.x, global_sec.y);
            if let Some(star) = star_map.get(&hash_key) {
                let sec_to_screen = VecI {
                    x: x * sec_size as i32,
                    y: y * sec_size as i32,
                };
                draw.draw_circle(
                    sec_to_screen.x + (sec_size / 2.) as i32,
                    sec_to_screen.y + (sec_size / 2.) as i32,
                    (star.radius / 2000.) * (sec_size / 2.),
                    Color::from(star.star_color),
                );
            }
        }
    }
    handle_mouse_hover(&star_map, global_pos, draw, sec_size);
}

fn handle_zoom(rl: &RaylibHandle, sec_size: f32) -> f32 {
    let zoom_sen = sec_size * rl.get_frame_time();
    if rl.is_key_down(KEY_E) {
        return sec_size + zoom_sen;
    }
    if rl.is_key_down(KEY_Q) {
        return match sec_size > 6. {
            true => sec_size - zoom_sen,
            false => sec_size,
        };
    }
    return sec_size;
}

fn handle_mouse_hover(
    star_map: &HashMap<u64, StarSystem>,
    global_pos: &mut Vector2,
    draw: &mut RaylibDrawHandle,
    sec_size: f32,
) {
    if let Some(star) = star_map.get(&jonk_utils::cantor_hash(
        global_pos.x as i32 + (draw.get_mouse_x() / sec_size as i32),
        global_pos.y as i32 + (draw.get_mouse_y() / sec_size as i32),
    )) {
        draw_debug_star_menu(star, draw);
    }
}

fn draw_debug_star_menu(star: &StarSystem, draw: &mut RaylibDrawHandle) {
    let lines = vec![
        format!("Radius: {:.2}", star.radius),
        format!("Luminosity: {:.2} lums", star.luminosity),
        format!("Temp: {:.2}K", star.surface_temp),
        format!("Mass: {:.2} Solar masses", star.mass),
        format!("Planets: {}", star.planets.len()),
        format!("Color: {:?}", star.star_color),
        format!("location: {}, {}", star.location.x, star.location.y),
    ];
    let planet_lines: Vec<String> = star
        .planets
        .iter()
        .map(|p| format!(" planet : {}", p.mass))
        .collect();
    let collect: Vec<&String> = lines.iter().chain(planet_lines.iter()).collect();
    draw_lines(draw, collect, 32, 12, 160);
}

fn draw_lines(draw: &mut RaylibDrawHandle, lines: Vec<&String>, f_size: i32, s_x: i32, s_y: i32) {
    let mut start_y = s_y;
    draw.draw_rectangle(s_x, start_y, 540, f_size * lines.len() as i32, COLORS.bg);
    for s in lines {
        draw.draw_text(&s, s_x, start_y, f_size, Color::WHITE);
        start_y += f_size;
    }
}

fn handle_key_press(rl: &RaylibHandle, global_pos: &mut Vector2, sensitivity: f32) {
    if rl.is_key_down(KEY_K) {
        global_pos.y -= sensitivity;
    }
    if rl.is_key_down(KEY_L) {
        global_pos.x += sensitivity;
    }
    if rl.is_key_down(KEY_J) {
        global_pos.y += sensitivity;
    }
    if rl.is_key_down(KEY_H) {
        global_pos.x -= sensitivity;
    }
}
fn handle_mouse_click(rl: &RaylibHandle, screen_state: &ScreenState) -> ScreenState {
    if rl.is_mouse_button_pressed(MOUSE_LEFT_BUTTON) {
        return match screen_state {
            ScreenState::UniMap => ScreenState::StarSystemMap,
            ScreenState::StarSystemMap => ScreenState::UniMap,
        };
    }
    return screen_state.clone();
}
